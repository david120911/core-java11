package alibaba.code.guideline.engineering.structure.lib.dependency;

public class LibraryDependenceTest {

    /**
     *
     * 在项目中经常遇到各种依赖库，会遇到一些称呼：
     * 一方库，二方库，三方库，现在对其范围进行解释，备忘一下。
     * 一方库：本工程范围内，各个模块和包之间的相互依赖。
     * 二方库：引入的同一个公司内部的其他工程。
     * 三方库：公司以外的其他依赖，比如apache，google等。
     *
     *
     */



    /**
     *
     * 在 Maven 中，任何一个项目和构件都必须有自己的版本。版本的值可能是 1.0.0、1.0-alpha-4、
     * 1.3-SNAPSHOT 等，其中 1.0.0、1.0-alpha-4 是稳定的发布版本，而 1.3-SNAPSHOT 为不稳定的快照版本。
     * Maven 为什么要添加一个快照版本的控制呢？
     * 假设张三在开发用户管理模块的 1.1 版本，该版本还没有正式发布。
     * 以前的用户管理模块和权限管理模块是由李四在单独开发的。
     * 其中，权限管理模块的功能是依赖用户管理模块的。
     * 在开发过程中，张三经常要将最新的用户管理模块构建输出，交给李四，
     * 让他对权限管理模块进行开发集成和调试。这种问题，如果由用户自己手动控制的话，
     * 相对比较麻烦。但 Maven 基于快照机制，就能自动解决这个问题。
     * 基于 Maven 的快照机制，张三只需将用户管理模块的版本设置成 1.1-SNAPSHOT，然后发布到私服中。
     * 在发布过程中，Maven 会自动为构件打上时间戳，比如 1.1-20161211.111111-11，
     * 表示 2016 年 12 月 11 日 11 点 11 分 11 秒的第 11 次的快照。有了这个时间戳，
     * Maven 就能随时找到仓库中用户管理构件 1.1-SNAPSHOT 版本的最新文件。
     * 这时，李四配置对用户管理模块的 1.1-SNAPSHOT 版本的依赖，当他构建权限管理模块的时候，
     * Maven 会自动从仓库中检测用户管理 1.1-SNAPSHOT 的最新构件，发现最新构件后就自动下载。
     * Maven 默认情况下，每天检测一次（具体实际情况，由参考配置的 updatePolicy 控制），
     * 当然，也可以使用 mvn-U 强制让 Maven 检测更新。如 mvn clean install-U。
     * 基于这样的机制，张三在构建成功后，将构件发布到仓库，李四可以完全考虑用户管理模块的构件，
     * 并且他还能确保随时得到用户管理模块的最新可用的快照构件，这些所有的一切都由 Maven 自动完成。
     * 快照版本只应该在开发团队内部的项目或模块之间依赖使用。这个时候，
     * 团队成员对这些快照版本的依赖具有完全的理解和控制权利。
     * 项目不应该依赖任何团队外部的快照版本依赖。由于快照版本的不稳定性，
     * 这样的依赖会造成潜在的危险。也就是说，即使项目构建这次成功了，由于外部的快照版本依赖会
     * 随时间改变而再次更新，下次构建的时候有可能会失败。
     *
     */


    /**
     *
     *(二) 二方库依赖
     * 1. 【强制】定义 GAV 遵从以下规则:
     * 1) GroupID格式:com.{公司/BU }.业务线.[子业务线]，最多4级。
     * 说明:{公司/BU} 例如:alibaba/taobao/tmall/aliexpress 等 BU 一级;子业务线可选。
     * 正例:com.taobao.jstorm 或 com.alibaba.dubbo.register
     * 2) ArtifactID格式:产品线名-模块名。语义不重复不遗漏，先到中央仓库去查证一下。
     * 正例:dubbo-client / fastjson-api / jstorm-tool
     * 3) Version:详细规定参考下方。
     *
     *
     *
     * 2. 【强制】二方库版本号命名方式:主版本号.次版本号.修订号
     * 1) 主版本号:当做了不兼容的API 修改，或者增加了能改变产品方向的新功能。
     * 2) 次版本号:当做了向下兼容的功能性新增(新增类、接口等)。
     * 3) 修订号:修复 bug，没有修改方法签名的功能加强，保持 API 兼容性。
     * 说明:注意:起始版本号必须为:1.0.0，而不是 0.0.1 正式发布的类库必须先去中央仓库 进行查证，使版本号有延续性，
     * 正式版本号不允许覆盖升级。如当前版本:1.3.3，那么下一 个合理的版本号:1.3.4 或 1.4.0 或 2.0.0
     *
     *
     * 3. 【强制】线上应用不要依赖 SNAPSHOT 版本(安全包除外)。
     * 说明:不依赖 SNAPSHOT 版本是保证应用发布的幂等性。另外，也可以加快编译时的打包构建。
     *
     *
     * 4. 【强制】二方库的新增或升级，保持除功能点之外的其它 jar 包仲裁结果不变。如果有改变，
     * 必须明确评估和验证，建议进行 dependency:resolve 前后信息比对，如果仲裁结果完全不一 致，
     * 那么通过 dependency:tree 命令，找出差异点，进行<excludes>排除 jar 包。
     *
     *
     *5. 【强制】二方库里可以定义枚举类型，参数可以使用枚举类型，但是接口返回值不允许使用枚
     * 举类型或者包含枚举类型的 POJO 对象。
     *
     *
     * 6. 【强制】依赖于一个二方库群时，必须定义一个统一的版本变量，避免版本号不一致。
     * 说明:依赖 springframework-core,-context,-beans，它们都是同一个版本，
     * 可以定义一 个变量来保存版本:${spring.version}，定义依赖的时候，引用该版本。
     *
     *
     * 7. 【强制】禁止在子项目的 pom 依赖中出现相同的 GroupId，相同的 ArtifactId，
     * 但是不同的 Version。
     * 说明:在本地调试时会使用各子项目指定的版本号，但是合并成一个 war，只能有一个版本号
     * 出现在最后的 lib 目录中。可能出现线下调试是正确的，发布到线上却出故障的问题。
     *
     *
     * 8. 【推荐】所有 pom 文件中的依赖声明放在<dependencies>语句块中，所有版本仲裁放在
     * <dependencyManagement>语句块中。 说明:<dependencyManagement>里只是声明版本，
     * 并不实现引入，因此子项目需要显式的声 明依赖，version
     * 和 scope 都读取自父 pom。而<dependencies>所有声明在主 pom 的
     * <dependencies>里的依赖都会自动引入，并默认被所有的子项目继承。
     *
     *
     * 9. 【推荐】二方库不要有配置项，最低限度不要再增加配置项。
     *
     *
     * 10. 【参考】为避免应用二方库的依赖冲突问题，二方库发布者应当遵循以下原则:
     * 1)精简可控原则。移除一切不必要的 API 和依赖，只包含 Service API、必要的领域模型对
     * 象、Utils 类、常量、枚举等。如果依赖其它二方库，尽量是 provided 引入，让二方库使用
     * 者去依赖具体版本号;无 log 具体实现，只依赖日志框架。 2)稳定可追溯原则。
     * 每个版本的变化应该被记录，二方库由谁维护，源码在哪里，都需要能 方便查到。除非用户主动升级版本，
     * 否则公共二方库的行为不应该发生变化。
     *
     *
     *
     *
     *
     *
     *
     *
     *
     */




}
