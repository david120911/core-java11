package alibaba.code.guideline.mysql.index.guide;

public class IndexGuideTest {


    /**
     * (二) 索引规约
     * 1. 【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。
     * 说明:不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明 显的;
     * 另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必 然有脏数据产生。
     */


    //生活中，我们会发现，当心里面担心某件事情时，一般都会发生；
    // 坏的事情总是比好的事情容易发生；某件东西久久都派不上用场，就可以丢掉；
    // 东西一丢掉，往往就必须要用它。排队买票时，另一排总是动的比较快；
    // 你换到另一排，你原来站的那一排，就开始动的比较快了；
    // 你站的越久，越有可能是站错了排。这样的事情不胜枚举。
    // 这样的现象称为“墨菲定律”。
    //
    //"墨菲定律"是一种心理学效应，又称“倒霉定律”，
    // 主要内容有：
    //任何事都没有表面看起来那么简单；
    //所有的事都会比你预计的时间长；
    //会出错的事总会出错；
    //如果你担心某种情况发生，那么它就更有可能发生
     /**　“墨菲定律”、“帕金森定律”和“彼德原理”并称为二十世纪西方文化三大发现。
      * “墨菲定律”（Murphy's Law）是这样说的：Anything that can go wrong will go wrong.
      ：“凡事只要有可能出错，那就一定会出错。”



      帕金森定律（Parkinson's Law）亦称“官场病”或“组织麻痹病”

      什么是帕金森定律
      　　帕金森定律是指企业在发展过程中往往会因业务的扩展或其他原因而出现的一种现象，
      这一效应使得企业的机构迅速膨胀资源浪费员工积极性下降。
      帕金森经过多年调查研究，发现一个人做一件事所耗费的时间差别如此之大：他可以在10分钟内看完一份报纸，也可以看半天；
      一个忙人20分钟可以寄出一叠明信片，
      但一个无所事事的老太太为了给远方的外甥女寄张明信片，可以足足花一整天：
      找明信片一个钟头，寻眼镜一个钟头，查地址半个钟头，写问候的话一个钟头零一刻钟……
      特别是在工作中，工作会自动地膨胀，占满一个人所有可用的时间，如果时间充裕，
      他就会放慢工作节奏或是增添其他项目以便用掉所有的时间。
      由此得出结论：在行政管理中，行政机构会像金字塔一样不断增多，行政人员会不断膨胀，
      每个人都很忙，但组织效率越来越低下。这条定律又被称为“金字塔上升”现象。
　他在书中阐述了机构人员膨胀的原因及后果：一个不称职的官员，可能有三条出路。
      第一是申请退职，把位子让给能干的人；第二是让一位能干的人来协助自己工作；
      第三是任用两个水平比自己更低的人当助手。
这第一条路是万万走不得的，因为那样会丧失许多权力；
      第二条路也不能走，因为那个能干的人会成为自己的对手；
      看来只有第三条路最适宜。于是，两个平庸的助手分担了他的工作，
      他自己则高高在上发号施令。两个助手既无能，也就上行下效，再为自己找两个无能的助手。
      如此类推，就形成了一个机构臃肿、人浮于事、相互扯皮、效率低下的领导体系。

      彼得原理的概述
      　　管理学家劳伦斯·彼得（Laurence．J．Peter）

      　　彼得原理（The Peter Principle）正是彼得根据千百个有关组织中不能胜任的失败实例的分析而归纳出来的。
      其具体内容是：“在一个等级制度中，每个职工趋向于上升到他所不能胜任的地位”。
      彼得指出，每一个职工由于在原有职位上工作成绩表现好（胜任），就将被提升到更高一级职位；
      其后，如果继续胜任则将进一步被提升，直至到达他所不能胜任的职位。由此导出的推论是：
      “每一个职位最终都将被一个不能胜任其工作的职工所占据。层级组织的工作任务多半是由尚未达到胜任阶层的员工完成的。
      ”每一个职工最终都将达到彼得高地，在该处他的提升商数（PQ）为零。
      至于如何加速提升到这个高地，有两种方法。其一，是上面的“拉动”，即依靠裙带关系和熟人等从上面拉；
      其二，是自我的“推动”，即自我训练和进步等，而前者是被普遍采用的。
(自我训练和进步很重要)
     */


    /**
     * 2. 【强制】 超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致;多表关联查询 时，
     * 保证被关联的字段需要有索引。
     * 说明:即使双表 join 也要注意表索引、SQL 性能。
     *
     */

    // join是数学上的笛卡尔积 数据量会非常的大

    /**
     * 3. 【强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，
     * 根据 实际文本区分度决定索引长度即可。 说明:索引的长度与区分度是一对矛盾体，一般对字符串类型数据，
     * 长度为 20 的索引，区分 度会高达 90%以上，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度 来确定。
     * <p>
     * <p>
     * <p>
     * <p>
     *
     */

    // varchar也能建立索引，但是没有这么做过
    //count(distinct left(列名，索引长度))/count(*)

    /**
     *
     * 4. 【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。
     * 说明:索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索 引。
     *
     */

    //看来都要每个网站要建立搜索引擎

    /**
     *
     *
     * 5. 【推荐】如果有 order by 的场景，请注意利用索引的有序性。order by 最后的字段是组合
     * 索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。
     * 正例:where a=? and b=? order by c; 索引:a_b_c 反例:索引中有范围查找，那么索引有序性无法利用，
     * 如:WHERE a>10 ORDER BY b; 索引 a_b 无法排序。
     *
     */


    // 索引

    /**
     *
     * 6. 【推荐】利用覆盖索引来进行查询操作，避免回表。
     * 说明:如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗?目录浏览 一下就好，
     * 这个目录就是起到覆盖索引的作用。 正例:能够建立索引的种类:主键索引、唯一索引、普通索引，
     * 而覆盖索引是一种查询的一种 效果，用explain的结果，extra列会出现:using index。
     *
     */


    /**
     *
     * 使用索引很简单，只要能写创建表的语句，就肯定能写创建索引的语句，
     * 然而， 会使用索引是一回事， 而深入理解索引原理又能恰到好处使用索引又是另一回事，
     * 这完全是两个天差地别的境界（我自己也还没有达到这层境界）。
     * 很大一部份程序员对索引的了解仅限于到“加索引能使查询变快”这个概念为止。
     *
     * 网上很多讲解索引的文章对索引的描述是这样的
     * 「索引就像书的目录， 通过书的目录就准确的定位到了书籍具体的内容」，
     * 这句话描述的非常正确， 但就像脱了裤子放屁，说了跟没说一样，
     * 通过目录查找书的内容自然是要比一页一页的翻书找来的快，同
     * 样使用的索引的人难到会不知道，通过索引定位到数据比直接
     * 一条一条的查询来的快，不然他们为什么要建索引。
     *
     * 想要理解索引原理必须清楚一种数据结构「平衡树」(非二叉)，也就是b tree或者 b+ tree，
     * 重要的事情说三遍：“平衡树，平衡树，平衡树”。当然， 有的数据库也使用哈希桶作用索引的数据结构 ，
     * 然而， 主流的RDBMS都是把平衡树当做数据表默认的索引数据结构的。
     * 我们平时建表的时候都会为表加上主键， 在某些关系数据库中， 如果建表时不指定主键，
     * 数据库会拒绝建表的语句执行。 事实上， 一个加了主键的表，并不能被称之为「表」。
     * 一个没加主键的表，它的数据无序的放置在磁盘存储器上，一行一行的排列的很整齐，
     * 跟我认知中的「表」很接近。如果给表上了主键，
     * 那么表在磁盘上的存储结构就由整齐排列的结构转变成了树状结构，也就是上面说的「平衡树」结构
     * ，换句话说，就是整个表就变成了一个索引。
     * 没错， 再说一遍， 整个表变成了一个索引，也就是所谓的「聚集索引」。
     *
     * 这就是为什么一个表只能有一个主键， 一个表只能有一个「聚集索引」，
     * 因为主键的作用就是把「表」的数据格式转换成「索引（平衡树）」的格式放置。
     *
     *
     * 上图就是带有主键的表（聚集索引）的结构图。图画的不是很好， 将就着看。
     * 其中树的所有结点（底部除外）的数据都是由主键字段中的数据构成，
     * 也就是通常我们指定主键的id字段。最下面部分是真正表中的数据。
     * 假如我们执行一个SQL语句：
     * select * from table where id = 1256;
     * 首先根据索引定位到1256这个值所在的叶结点，
     * 然后再通过叶结点取到id等于1256的数据行。 这里不讲解平衡树的运行细节，
     * 但是从上图能看出，树一共有三层， 从根节点至叶节点只需要经过三次查找就能得到结果。
     *
     * 如果把这张表转换成平衡树结构（一棵非常茂盛和节点非常多的树），假设这棵树有10层，
     * 那么只需要10次IO开销就能查找到所需要的数据， 速度以指数级别提升，用大O标记法就是O(log n)，
     * n是记录总树，底数是树的分叉数，结果就是树的层次数。换言之，查找次数是以树的分叉数为底，
     * 记录总数的对数，用公式来表示就是
     * 用程序来表示就是Math.Log(100000000,10)，100000000是记录数，10是树的分叉数
     * （真实环境下分叉数远不止10）， 结果就是查找次数，这里的结果从亿降到了个位数。
     * 因此，利用索引会使数据库查询有惊人的性能提升。
     * 然而， 事物都是有两面的， 索引能让数据库查询数据的速度上升，
     * 而使写入数据的速度下降，原因很简单的， 因为平衡树这个结构必须一直维持在
     * 一个正确的状态， 增删改数据都会改变平衡树各节点中的索引数据内容，破坏树结构，
     * 因此，在每次数据改变时， DBMS必须去重新梳理树（索引）的结构以确保它的正确，
     * 这会带来不小的性能开销，也就是为什么索引会给查询以外的操作带来副作用的原因。
     *
     * （个人总结 建立索引就是建立了平衡树排序 类似于红黑树 红黑树 平衡二叉树）
     *讲完聚集索引，接下来聊一下非聚集索引， 也就是我们平时经常提起和使用的常规索引。
     *
     * 非聚集索引和聚集索引一样， 同样是采用平衡树作为索引的数据结构。索引树结构中各
     * 节点的值来自于表中的索引字段， 假如给user表的name字段加上索引 ，
     * 那么索引就是由name字段中的值构成，在数据改变时， DBMS需要一直
     * 维护索引结构的正确性。如果给表中多个字段加上索引 ， 那么就会出现多个
     * 独立的索引结构，每个索引（非聚集索引）互相之间不存在关联。 如下图：
     *
     * 非聚集索引和聚集索引的区别在于， 通过聚集索引可以查到需要查找的数据，
     * 而通过非聚集索引可以查到记录对应的主键值 ，
     * 再使用主键的值通过聚集索引查找到需要的数据，如下图：
     *
     *
     * 不管以任何方式查询表， 最终都会利用主键通过聚集索引来定位到数据，
     * 聚集索引（主键）是通往真实数据所在的唯一路径。
     * 然而， 有一种例外可以不使用聚集索引就能查询出所需要的数据，
     * 这种非主流的方法 称之为「覆盖索引」查询， 也就是平时所说的复合索引或者多字段索引查询。
     * 文章上面的内容已经指出， 当为字段建立索引以后， 字段中的内容会被同步到索引之中，
     * 如果为一个索引指定两个字段， 那么这个两个字段的内容都会被同步至索引之中。
     *
     * （覆盖索引是select的数据列只用从索引中就能够取得，
     * 不必读取数据行，换句话说查询列要被所建的索引覆盖。  搜狗定义）
     *
     * 通过非聚集索引index_birthday_and_user_name查找birthday等于1991-11-1的叶节点的内容，
     * 然而， 叶节点中除了有user_name表主键ID的值以外， user_name字段的值也在里面，
     * 因此不需要通过主键ID值的查找数据行的真实所在， 直接取得叶节点中user_name的值返回即可。
     * 通过这种覆盖索引直接查找的方式， 可以省略不使用覆盖索引查找的后面两个步骤，
     * 大大的提高了查询性能，如下图：
     *
     * 数据库索引的大致工作原理就是像文中所述， 然而细节方面可能会略有偏差，
     * 这但并不会对概念阐述的结果产生影响 。
     *
     * 回表的概念
     *
     * 先得出结论,根据下面的实验。如果我要获得['liu','25']这条记录。需要什么步骤。
     *
     * 1.先通过['liu']记录对应到普通索引index(name),获取到主键id:4.
     * 2.再通过clustered index，定位到行记录。也就是上面说的这条['liu','25']记录数据。
     * 因此，上述就是说的回表查询,先定位主键值，再定位行记录。多扫了一遍索引树。
     * 也能看到name这几个数据建立的B+树是怎么样的。也能看到我需要找到[liu]这个元素的话，需要两次查找。
     * 但是，如果我的需求是，除了获取name之外还需要获取age的话。
     * 这里就需要回表了。为什么？因为我找不到age数据。
     *
     *
     *
     */




    /**
     *
     * 7. 【推荐】利用延迟关联或者子查询优化超多分页场景。
     * 说明:MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，
     * 返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，
     * 要么对超过 特定阈值的页数进行 SQL 改写。
     * 正例:先快速定位需要获取的 id 段，然后再关联:
     * SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT
     * 100000,20 ) b where a.id=b.id
     *
     */

    // 正例：
    //先快速定位需要获取的id段，然后再关联：
    // select a.* from 表 1 a,（select id from 表 1 where 条件 LIMIT 10000，20） b where a.id = b.id


    /**
     *
     * 8. 【推荐】SQL 性能优化的目标:至少要达到 range 级别，要求是 ref 级别，
     * 如果可以是 consts 最好。
     * 说明:
     * 1)consts 单表中最多只有一个匹配行(主键或者唯一索引)，在优化阶段即可读取到数据。
     * 2)ref 指的是使用普通的索引(normal index)。
     * 3)range 对索引进行范围检索。
     * 反例:explain 表的结果，type=index，索引物理文件全扫描，速度非常慢，
     * 这个 index 级 别比较 range 还低，与全表扫描是小巫见大巫。
     *
     */

    // 很好的建议

    /**
     *
     * 9. 【推荐】建组合索引的时候，区分度最高的在最左边。
     * 正例:如果 where a=? and b=? ，a 列的几乎接近于唯一值，那么只需要单建 idx_a 索引即 可。
     * 说明:存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。
     * 如:where a>? and b=? 那么即使 a 的区分度更高，也必须把 b 放在索引的最前列。
     *
     */
    // 是的

    /**
     *
     * 10. 【推荐】防止因字段类型不同造成的隐式转换，导致索引失效。
     * <p>
     * <p>
     */


     /**
     * 11. 【参考】创建索引时避免有如下极端误解:
     * 1)宁滥勿缺。误认为一个查询就需要建一个索引。
     * 2)宁缺勿滥。误认为索引会消耗空间、严重拖慢更新和新增速度。
     * 3)抵制惟一索引。误认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。
     **/



     // 个人总结 要理解索引 就要理解平衡树  其实就是要理解先排序 然后根据排序去找数据 就是数据结构与算法里的排序 查找 插入
     //果然万事离不开增删改查 离不开算法  算法是最重要的。

    public static void main(String[] args) {


    }

}
